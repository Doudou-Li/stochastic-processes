
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Stochastic Valuation Processes</title><meta name="generator" content="MATLAB 9.8"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-05-25"><meta name="DC.source" content="documentation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Stochastic Valuation Processes</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Rationale</a></li><li><a href="#6">Introduction to the Matlab class</a></li><li><a href="#10">Brownian Motion</a></li><li><a href="#11">Geometric Brownian Motion</a></li><li><a href="#12">Merton&#8217;s Jump-Diffusion Model</a></li><li><a href="#13">Heston Model</a></li><li><a href="#14">Vasicek interest rate model</a></li><li><a href="#15">Cox-Ingersoll-Ross interest rate model</a></li><li><a href="#16">Utilities</a></li><li><a href="#17">Tick Imbalance Bars</a></li><li><a href="#18">Volume and Dollar Imbalance Bars</a></li><li><a href="#19">Future Work</a></li></ul></div><h2 id="1">Rationale</h2><p>This toolbox packages a set of stochastic processes for prices and rates simulation, aiming to create a synthetic dataset for quantitative back-testing of trading strategies and asset allocations methods.</p><p>Simulating synthetic stock prices and bond rates provides an alternative back-testing method that uses history to generate datasets with statistical characteristics estimated from the observed data. This method allows back-testing on a large sample of unseen scenarios, hence reducing the likelihood of overfitting to a particular historical data set.</p><p>Because each trading strategy needs an implementation tactic (a.k.a., trading rules) to enter, maintain, and exit the respective positions on each instrument, a simulation over thousands of different scenarios is mandatory. However, there is an implicit tradeoff.</p><p>The historical data will show the 'real' state of the financial instruments based on the realized combinations of events that affect each market. Thereby, a traditional portfolio manager will design a set of rules that optimize or hedge the profits for those specific combinations of events. Therefore, an investment strategy that relies on parameters fitted solely by one combination of events is doomed to fail.</p><p>Such a framework for designing trading strategies is limited in the amount of knowledge that can incorporate. So, simulating thousands or even millions of possibles scenarios for the future will robust the way that an econometric method exploits an inefficiency in the market.</p><p>Based on the previous postulate, I have created a toolbox that packages different stochastic processes (a.k.a, valuation methods) for back-testing synthetic data.</p><p>The processes that were for this version of the toolbox are:</p><p><b>Stock prices</b></p><div><ul><li>Brownian Motion</li><li>Geometric Brownian motion</li><li>Merton model</li><li>Heston model</li></ul></div><p><b>Bond Rates</b></p><div><ul><li>Vasicek model</li><li>Cox Ingersoll Ross model</li></ul></div><p>Without further due, let's briefly dive into each process and how you can use the toolbox in your Matlab session.</p><h2 id="6">Introduction to the Matlab class</h2><p>All the processes are methods that recreate the price path for an asset based on the user's configuration. As such, the user can initialize the class with the following command.</p><p>Please be aware that the user should enter the parameters as name-value arguments for the definition of the class.</p><pre class="codeinput"><span class="comment">% Creating the object that has the initialized class</span>
<span class="comment">% This is read as follows: Generate 5 securities with 252 datapoints</span>
<span class="comment">% each, were the time step between each observation is 1, and  the start</span>
<span class="comment">%  price for the securities is $100.</span>
sim = randomProcesses(<span class="string">"n"</span>, 5, <span class="string">"T"</span>, 252, <span class="string">"h"</span>, 1, <span class="string">"s0"</span>, 100);
</pre><p>In this case, each name-value argument is defined as follows:</p><div><ul><li><b>T:</b> number of observations to generate for each time series.</li><li><b>h:</b> the size of the step.</li><li><b>n:</b> number of paths to generate.</li><li><b>s0:</b> initial price to the state for each of path to generate, be aware that if you want to simulate rates, this number is considered as a pe</li><li>rcentage (e.g., 30 = 0.3 in the rates environment).</li><li><b>sigma:</b> trading intensity. This parameter is used for the volume generation process and is not related to the associated volatility of each instrument.</li></ul></div><p>In the case the user wants a rapid check of the documentation for each process, he/she can input the following command in the Matlab console.</p><pre class="codeinput">doc(<span class="string">"randomProcesses"</span>)
</pre><h2 id="10">Brownian Motion</h2><p>This method implements  a discrete time stochastic process for a Brownian motion that satisfies the following stochastic differential equation (SDE):</p><p><img src="documentation_eq06760059945068802488.png" alt="$$dX_t =\mu X_t \textrm{dt}+\sigma \;X_t \;dW_t$$" style="width:160px;height:14px;"></p><p><img src="documentation_eq01313795468942889415.png" alt="$$X\left(0\right)=X_0$$" style="width:70px;height:15px;"></p><p>The Euler&#8211;Maruyama method is used for the numerical solution of the SDE and has the following recurrence:</p><p><img src="documentation_eq01327988016825590284.png" alt="$$\begin{array}{l}X\left(k+1\right)=X\left(k\right)+\mu X\left(k-1\right)\Delta&#xA;t+\sigma X\left(k-1\right)W\;\\\textrm{where}\;\\W=Z\left(k\right)\sqrt{\Delta&#xA;t\;}\\\;Z\left(k\right)\;\textrm{is}\;\textrm{white}\;\textrm{noise}\end{array}$$" style="width:328px;height:70px;"></p><p>The name-value arguments for the method are:</p><div><ul><li><b>mu</b>(float): Historical means of returns</li><li><b>sigma</b>(float): Historical volatility of returns</li><li><b>sto_vol</b>(logical): Optional argument for the helper that states if the volatility should be constant of stochastic in the data generation process. Default is <b>false</b> for this process.</li></ul></div><p>Usage:</p><pre class="codeinput"><span class="comment">% Generate the prices paths and save the variable</span>
brownian_prices = sim.brownian_prices(<span class="string">"mu"</span>, 0.04, <span class="string">"sigma"</span>, 0.15);

<span class="comment">% plot the results</span>
plot(brownian_prices)
title(<span class="string">'Assets simulated prices for Brownian Motion'</span>)
ylabel(<span class="string">'Prices'</span>)
xlabel(<span class="string">'Time step'</span>)
</pre><img vspace="5" hspace="5" src="documentation_01.png" alt=""> <h2 id="11">Geometric Brownian Motion</h2><p>The Geometric Brownian Motion (GBM) was popularized by Fisher Black and Myron Scholes in their paper The Pricing of Options and Corporate Liabilities. In that paper, they derive the Black Scholes equation. The GBM is essentially a Brownian Motion with constant drift and a stochastic volatility component.</p><p>The stochastic differential equation (SDE) which describes the evolution of a Geometric Brownian Motion stochastic process is the following:</p><p><img src="documentation_eq01884337267219423662.png" alt="$$\begin{array}{l}dX_t =\mu X_t \textrm{dt}+\sigma \left(t\right)X_t \;dW_t&#xA;\\X\left(0\right)=X_0 \end{array}$$" style="width:177px;height:33px;"></p><p>The Euler&#8211;Maruyama method is used for the numerical solution of the SDE and has the following recurrence:</p><p><img src="documentation_eq02579310232039122077.png" alt="$$\begin{array}{l}X\left(k+1\right)=X\left(k\right)+\textrm{uX}\left(k-1\right)\Delta&#xA;t+\sigma \left(k\right)X\left(k-1\right)W\\\textrm{where}\;\\W=Z\left(k\right)\sqrt{\Delta&#xA;t}\;\\Z\left(k\right)\;\textrm{is}\;\textrm{white}\;\textrm{noise}\;\end{array}$$" style="width:350px;height:70px;"></p><p>The name-value arguments for the method are:</p><div><ul><li><b>mu</b>(float): Historical means of returns</li><li><b>sigma</b>(float): Historical volatility of returns</li><li><b>sto_vol</b>(logical): Optional argument for the helper that states if the volatility should be constant of stochastic in the data generation process. Default is <b>true</b> for this process.</li></ul></div><pre class="codeinput"><span class="comment">% Usage:</span>

<span class="comment">% Generate the prices paths and save the variable</span>
gbm_prices = sim.gbm_prices(<span class="string">"mu"</span>, 0.04, <span class="string">"sigma"</span>, 0.15);

<span class="comment">% plot the results</span>
plot(gbm_prices)
title(<span class="string">'Assets simulated prices for Geometric Brownian Motion'</span>)
ylabel(<span class="string">'Prices'</span>)
xlabel(<span class="string">'Time step'</span>)
</pre><img vspace="5" hspace="5" src="documentation_02.png" alt=""> <h2 id="12">Merton&#8217;s Jump-Diffusion Model</h2><p>In essence, this is a process that allows for a positive probability of a stock price change of extraordinary magnitude, no matter how small the time interval between successive observations. More formally, this is a Poisson-driven process, in which the "event" is the arrival of an essential piece of information that creates an abnormal increase/decrease in price.</p><p>The stochastic differential equation (SDE) which describes the evolution of a Merton stochastic process is the following:</p><p><img src="documentation_eq01355695981268485231.png" alt="$$\begin{array}{l}dX_t =\mu X_t \textrm{dt}+\sigma \left(t\right)X_t \;dW_t&#xA;+dJ_t \\X\left(0\right)=X_0 \end{array}$$" style="width:215px;height:33px;"></p><p>The Euler&#8211;Maruyama method is used for the numerical solution of the SDE and has the following recurrence:</p><p><img src="documentation_eq03990231821594188460.png" alt="$$\begin{array}{l}X\left(k+1\right)=X\left(k\right)+\mu X\left(k-1\right)\Delta&#xA;t+\sigma \left(t\right)X\left(k-1\right)W+X\left(k\right)\left(\sum_{i=0}^{N_t&#xA;} \left(Y_i -1\right)\right)\\\textrm{where}\\N_t \;\textrm{is}\;a\;\textrm{Poisson}\;\textrm{process}\;\textrm{with}\;\textrm{rate}\;\lambda&#xA;\;\textrm{and}\;Y_i \;\textrm{has}\;a\;\log \;\textrm{normal}\;\textrm{distribuition}\ldotp&#xA;\;\\\textrm{Also}\;W=Z\left(k\right)\sqrt{\Delta t}\;\\Z\left(k\right)\;\textrm{is}\;\textrm{white}\;\textrm{noise}\ldotp&#xA;\end{array}$$" style="width:506px;height:97px;"></p><p>The name-value arguments for the method are:</p><div><ul><li><b>lambda</b>(double): Moment of arrival of an important piece of information.</li><li><b>mu</b>(double): Historical mean of returns.</li><li><b>sigma</b>(double): Historical volatility of returns.</li><li><b>sto_vol</b>(logical): Optional argument for the helper that states if the volatility should be constant of stochastic in the data generation process. Default is <b>true</b> for this process.</li></ul></div><p>Usage:</p><pre class="codeinput"><span class="comment">% Generate the prices paths and save the variable</span>
<span class="comment">% The arrival of critical information will arrive every 30</span>
<span class="comment">% iterations until the end of the data points.</span>
merton_prices = sim.merton_prices(<span class="string">"mu"</span>, 0.04, <span class="string">"sigma"</span>, 0.15, <span class="string">'lambda'</span>, 30);

<span class="comment">% plot the results</span>
plot(merton_prices)
title(<span class="string">'Assets simulated prices for the Merton&#8217;s Jump-Diffusion model'</span>)
ylabel(<span class="string">'Prices'</span>)
xlabel(<span class="string">'Time step'</span>)
</pre><img vspace="5" hspace="5" src="documentation_03.png" alt=""> <h2 id="13">Heston Model</h2><p>The original Geometric Brownian Motion stochastic process assumes that volatility over time is constant. In the early 1990s, Steven Heston relaxed this assumption and extended the Geometric Brownian Motion model to include stochastic volatility. The resulting model is called the Heston model.</p><p>In the Heston model, the volatility over time evolves according to the Cox Ingersoll Ross stochastic process. As such, the model makes use of two Wiener processes, one for the Cox Ingersoll Ross process and another for the Geometric Brownian Motion process. These two Wiener processes are correlated using Singular Value Decomposition.</p><p>The stochastic differential equations (SDE) for the Cox-Ingersoll-Ross and the Heston model are</p><p><img src="documentation_eq14664787671637930070.png" alt="$$\begin{array}{l}\textrm{Price}\;\textrm{evolution}\\dS_t =\mu S_t \;\textrm{dt}+S_t&#xA;\sqrt{V}dW_1 \;\\S\left(0\right)=S_0 \\\;\\\textrm{Volatility}\;\textrm{evolution}\\dV_t&#xA;=k\left(\theta -V_t \right)\textrm{dt}+\sigma \sqrt{V}dW_2 \\V\left(0\right)=V_0&#xA;\;\end{array}$$" style="width:194px;height:122px;"></p><p>The Euler&#8211;Maruyama method is used for the numerical solution of the SDE and has the following recurrence:</p><p><img src="documentation_eq01619820080346165334.png" alt="$$\begin{array}{l}\textrm{Price}\;\textrm{numerical}\;\textrm{approximation}\\S\left(i\right)=\textrm{rf}\;S\left(i-1\right)\Delta&#xA;t+\sqrt{V\left(i\right)}S\left(i-1\right)W_1 \\\textrm{where}\;W_1 =Z_1 \left(k\right)\sqrt{\Delta&#xA;t}\\Z_1 \left(k\right)\;\textrm{is}\;\textrm{the}\;\textrm{correlated}\;\textrm{white}\;\textrm{noise}\\\;\\\textrm{Volatility}\;\textrm{numerical}\;\textrm{approximation}\\V\left(j\right)=k\left(\theta&#xA;-V\left(j-1\right)\right)\Delta t+\sigma \sqrt{V\left(j-1\right)}W_2 \\\textrm{where}\;W_2&#xA;=Z_2 \left(k\right)\sqrt{\Delta t}\;\\Z_2 \left(k\right)\;\textrm{is}\;\textrm{the}\;\textrm{correlated}\;\textrm{white}\;\textrm{noise}\end{array}$$" style="width:295px;height:161px;"></p><p>The name-value arguments for the method are:</p><div><ul><li><b>rf</b>(double): Risk-free interest rate, theoretical rate on an asset carrying no risk. Default value is 0.02</li><li><b>theta</b>(double): Long term price variance. Default value is 1</li><li><b>k</b>(double): Rate reversion to the long term variance. Default value is 0.5</li><li><b>sigma</b>(double): Historical volatility of returns. Default value is 1</li><li><b>sto_vol</b>(logical): Optional argument for the helper that states if the volatility should be constant of stochastic in the data generation process. Default is <b>false</b> for this process.</li></ul></div><p>Usage:</p><pre class="codeinput"><span class="comment">% Generate the prices paths and save the variable</span>
heston_prices = sim.heston_prices(<span class="string">'rf'</span>, 0.01, <span class="string">'theta'</span>, 0.5, <span class="keyword">...</span>
    <span class="string">'k'</span>, 0.8, <span class="string">'sigma'</span>, 0.2);

<span class="comment">% plot the results</span>
plot(heston_prices)
title(<span class="string">'Assets simulated prices for the Heston model'</span>)
ylabel(<span class="string">'Prices'</span>)
xlabel(<span class="string">'Time step'</span>)
</pre><img vspace="5" hspace="5" src="documentation_04.png" alt=""> <h2 id="14">Vasicek interest rate model</h2><p>The Vasicek interest rate model (or merely the Vasicek model) is a mathematical method of modeling interest rate movements. The model describes the evolution of an interest rate as a factor composed of market risk, time, and equilibrium value, where the rate tends to revert towards the mean of those factors over time. Essentially, it predicts where interest rates will end up at the end of a given period, given current market volatility, the long-run mean interest rate value, and a given market risk factor.</p><p>The stochastic differential equation (SDE) for the Vasicek Interest Rate Model process is given by</p><p><img src="documentation_eq04023131018870915065.png" alt="$$\begin{array}{l}dS_t =\lambda \left(\mu -S_t \right)+\sigma dW_t \\S\left(0\right)=S_0&#xA;\end{array}$$" style="width:155px;height:33px;"></p><p>The Euler&#8211;Maruyama method is used for the numerical solution of the SDE and has the following recurrence:</p><p><img src="documentation_eq17915897596606913497.png" alt="$$\begin{array}{l}S\left(k\right)=\lambda \left(\mu -S\left(k-1\right)\right)\Delta&#xA;t+\sigma S\left(k-1\right)W\\\textrm{where}\;\\W=Z\left(k\right)\sqrt{\Delta&#xA;t}\\Z\left(k\right)\;\textrm{is}\;\textrm{white}\;\textrm{noise}\end{array}$$" style="width:280px;height:70px;"></p><p>The name-value arguments for the method are:</p><div><ul><li><b>mu</b>(double): Long term mean level. All future trajectories of s will evolve around a mean level &#956; in the long run. Default value is 0</li><li><b>sigma</b>(double): Instantaneous volatility, measures instant by instant the amplitude of randomness entering the system. Higher &#963; implies more randomness. Default value is 1</li><li><b>lambda</b>(double): Speed of reversion. &#955; characterizes the velocity at which such trajectories will regroup around &#956; in time. Default value is 0.5</li><li><b>sto_vol</b>(logical): Optional argument for the helper that states if the volatility should be constant of stochastic in the data generation process. Default is <b>false</b> for this process.</li></ul></div><p>Usage:</p><pre class="codeinput"><span class="comment">% Create the object for the rate series</span>
<span class="comment">% The following object can be read as follows: Create 5 instruments with</span>
<span class="comment">% 252 observations each, were the time step between the observations is 1</span>
<span class="comment">% and the initial rate is 0.02 (i.e., 2%)</span>
sim2 = randomProcesses(<span class="string">'n'</span>, 5, <span class="string">'T'</span>, 252, <span class="string">'h'</span>, 1, <span class="string">'s0'</span>, 2);

<span class="comment">% Generate the prices paths and save the variable</span>
vas_rates = sim2.vas_rates(<span class="string">"mu"</span>, 0.018, <span class="string">"sigma"</span>, 0.03, <span class="string">'lambda'</span>, 0.9);

<span class="comment">% plot the results</span>
plot(vas_rates)
title(<span class="string">'Rates simulated for the Vasicek interest rate model'</span>)
ylabel(<span class="string">'Rates'</span>)
xlabel(<span class="string">'Time step'</span>)
</pre><img vspace="5" hspace="5" src="documentation_05.png" alt=""> <h2 id="15">Cox-Ingersoll-Ross interest rate model</h2><p>The Cox-Ingersoll-Ross model (CIR) is a mathematical formula used to model interest rate movements and is driven by a sole source of market risk. It is used as a method to forecast interest rates.  The stochastic process is often used in the valuation of interest rate derivatives and has been used in the Heston model to describe the evolution of volatility over time. One interesting characteristic of the CIR stochastic process is that it is mean reverting.</p><p><i><b>The main distinction with the Vasicek model is that the Cox-Ingersoll Ross model does not allow for negative interest rates.</b></i></p><p>The stochastic differential equation (SDE) for the Cox-Ingersoll-Ross Interest Rate Model process is given by</p><p><img src="documentation_eq17376074189778244079.png" alt="$$\begin{array}{l}dS_t =\lambda \left(\mu -S_t \right)\textrm{dt}+o\sqrt{S_t&#xA;}dW_t \\S\left(0\right)=S_0 \end{array}$$" style="width:195px;height:34px;"></p><p>The Euler&#8211;Maruyama method is used for the numerical solution of the SDE and has the following recurrence:</p><p><img src="documentation_eq15424525154484281402.png" alt="$$\begin{array}{l}S\left(k\right)=\lambda \left(\mu -S\left(k-1\right)\right)\Delta&#xA;t+\sigma \sqrt{S\left(k-1\right)}W\\\textrm{where}\\W=Z\left(k\right)\sqrt{\Delta&#xA;t}\;\\Z\left(k\right)\;\textrm{is}\;\textrm{white}\;\textrm{noise}\end{array}$$" style="width:292px;height:71px;"></p><p>The name-value arguments for the method are:</p><div><ul><li><b>mu</b>(double): Long term mean level. All future trajectories of s will evolve around a mean level &#956; in the long run. Default value is 0</li><li><b>sigma</b>(double): Instantaneous volatility, measures instant by instant the amplitude of randomness entering the system. Higher &#963; implies more randomness. Default value is 1</li><li><b>lambda</b>(double): Speed of reversion. &#955; characterizes the velocity at which such trajectories will regroup around &#956; in time. Default value is 0.5</li><li><b>sto_vol</b>(logical): Optional argument for the helper that states if the volatility should be constant of stochastic in the data generation process. Default is <b>false</b> for this process.</li></ul></div><p>Usage:</p><pre class="codeinput"><span class="comment">% Generate the prices paths and save the variable</span>
cir_rates = sim2.cir_rates(<span class="string">"mu"</span>, 0.018, <span class="string">"sigma"</span>, 0.03, <span class="string">'lambda'</span>, 0.9);

<span class="comment">% plot the results</span>
plot(cir_rates)
title(<span class="string">'Rates simulated for the Cox-Ingersoll-Ross interest rate model'</span>)
ylabel(<span class="string">'Rates'</span>)
xlabel(<span class="string">'Time step'</span>)
</pre><img vspace="5" hspace="5" src="documentation_06.png" alt=""> <h2 id="16">Utilities</h2><p>Along with the stochastic models for stock prices and interest rates, several utility methods were implemented. Such as <b>Information driven bars</b> (see <i>Advances in Financial Machine Learning by Marcos L&oacute;pez de Prado</i>), <b>volume generation, or order flow</b> for each stock (see <i>Asymmetric Information and the Distribution of Trading Volume, Matthijs Lof</i>).</p><p>Order Flow Volume generation process based on the number of informed traders and the number of liquidity seekers for the market of a security. To check the details of the generation process please see:</p><div><ul><li>Lof, Matthijs and van Bommel, Jos, Asymmetric Information and the Distribution of Trading Volume (May 29, 2019). Available at SSRN: <a href="https://ssrn.com/abstract=2726187">&lt;https://ssrn.com/abstract=2726187</a>&gt; or <a href="https://dx.doi.org/10.2139/ssrn.2726187">&lt;http://dx.doi.org/10.2139/ssrn.2726187</a>&gt;</li></ul></div><p><b>Usage in Matlab:</b></p><p>The name-value arguments for the method are:</p><div><ul><li><b>eta</b>(double): Proportion of informed trade. Default value is 0.1</li><li><b>M</b>(double): Proportion of liquidity seekers. Default value is 0.3</li><li><b>market_prices</b>(matrix): tick prices for an financial instrument.</li></ul></div><p>Usage:</p><pre class="codeinput">volumes = sim.order_flow(<span class="string">"eta"</span>, 0.15, <span class="string">"market_prices"</span>, heston_prices(:, 1));
bar(volumes,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
ylabel({<span class="string">'Volume'</span>});
xlabel({<span class="string">'Time Step'</span>});
title({<span class="string">'Generated Volumes for a Heston model'</span>});
<span class="comment">% Information Driven Bars</span>
<span class="comment">% The following descriptions came from the book &lt;https://www.bookdepository.com/Advances-Financial-Machine-Learning-Marcos-Lopez-de-Prado/9781119482086?ref=grid-view&amp;qid=1590373792725&amp;sr=1-1</span>
<span class="comment">% Advances in Financial Machine Learning&gt; by Marcos L&oacute;pez de Prado</span>
</pre><img vspace="5" hspace="5" src="documentation_07.png" alt=""> <h2 id="17">Tick Imbalance Bars</h2><p>Consider a sequence of ticks <img src="documentation_eq02395359018717433193.png" alt="${\left\lbrace \left(p_t \;,v_t \;\right)\right\rbrace }_{t=1,\ldotp \ldotp \ldotp ,T}$" style="width:102px;height:18px;"> , where <img src="documentation_eq17977949795708531195.png" alt="$p_t$" style="width:11px;height:10px;"> is the price associated with tick <img src="documentation_eq12656067504604335951.png" alt="$t$" style="width:6px;height:10px;"> and <img src="documentation_eq08818069549110672446.png" alt="$v_t$" style="width:10px;height:10px;"> is the volume associated with tick <img src="documentation_eq12656067504604335951.png" alt="$t$" style="width:6px;height:10px;">. The so-called tick rule defines a sequence <img src="documentation_eq00640509164157781031.png" alt="${\left\lbrace b_t \right\rbrace }_{t=1,\ldotp \ldotp \ldotp ,T}$" style="width:63px;height:18px;"> where</p><p><img src="documentation_eq13525414045203502305.png" alt="$$b_t =\left\lbrace \begin{array}{ll}b_{t-1}  &amp; \textrm{if}\;\Delta p_t =0\\\frac{\left|\Delta&#xA;p_t \right|}{\Delta p_t } &amp; \textrm{if}\;\Delta p_t \not= 0\end{array}\right.$$" style="width:154px;height:45px;"></p><p>with <img src="documentation_eq08842311265274684213.png" alt="$b_t \in \left\lbrace -1,1\right\rbrace$" style="width:75px;height:15px;">, and the boundary condition <img src="documentation_eq16964906757373332202.png" alt="$b_0$" style="width:11px;height:13px;"> is set to match the terminal value <img src="documentation_eq03684088752483519477.png" alt="$b_T$" style="width:14px;height:13px;"> from the immediately preceding bar. The idea behind tick imbalance bars (TIB's) is to sample bars whenever tick imbalances exceed our expectations. We wish to determine the tick index, <img src="documentation_eq14047577632175690031.png" alt="$T$" style="width:11px;height:10px;">, such that the accumulation of signed ticks (signed according to the tick rule) exceeds a given threshold. Next, let us discuss the procedure to determine <img src="documentation_eq14047577632175690031.png" alt="$T$" style="width:11px;height:10px;">.</p><p>First, we define the tick imbalance at time <img src="documentation_eq14047577632175690031.png" alt="$T$" style="width:11px;height:10px;"> as</p><p><img src="documentation_eq17666801634595879586.png" alt="$$\theta_t =\sum_{t=1}^T b_t$$" style="width:64px;height:43px;"></p><p>Second, we compute the expected value of <img src="documentation_eq03085669592695804257.png" alt="$\theta_T$" style="width:14px;height:13px;"> at the beginning of the bar, <img src="documentation_eq16636349566427321344.png" alt="$E_0 \left\lbrack \theta_T \right\rbrack =E_0 \left\lbrack T\right\rbrack \left(P\left\lbrack b_t =1\right\rbrack -P\left\lbrack b_t =-1\right\rbrack \right)$" style="width:261px;height:15px;">, where <img src="documentation_eq05293451273677812421.png" alt="$E_0 \left\lbrack T\right\rbrack$" style="width:36px;height:15px;"> is the <b>expected size of the tick bar</b>, <img src="documentation_eq08773480983915424384.png" alt="$P\left\lbrack b_t =1\right\rbrack$" style="width:58px;height:15px;"> is the unconditional probability that a tick is <b>classified as a buy</b>, and <img src="documentation_eq13915784797954448941.png" alt="$P\left\lbrack b_t =-1\right\rbrack$" style="width:70px;height:15px;"> is the unconditional probability that a tick is <b>classified as a sell</b>. Since <img src="documentation_eq08492683881745639096.png" alt="$P\left\lbrack b_t =1\right\rbrack +P\left\lbrack b_t =-1\right\rbrack =1$" style="width:174px;height:15px;">, then <img src="documentation_eq12765332598026259827.png" alt="$E_0 \left\lbrack \theta_T \right\rbrack =E_0 \left\lbrack T\right\rbrack \left(2P\left\lbrack b_t =1\right\rbrack -1\right)$" style="width:204px;height:15px;"></p><p>In practice, we can estimate <img src="documentation_eq05293451273677812421.png" alt="$E_0 \left\lbrack T\right\rbrack$" style="width:36px;height:15px;"> as an exponentially weighted moving average of <img src="documentation_eq14047577632175690031.png" alt="$T$" style="width:11px;height:10px;"> values from prior bars, and <img src="documentation_eq14866131842201783596.png" alt="$\left(2P\left\lbrack b_t =1\right\rbrack -1\right)$" style="width:102px;height:15px;"> as an exponentially weighted moving average of <img src="documentation_eq08146083210078216201.png" alt="$b_t$" style="width:10px;height:13px;"> values from prior bars.</p><p>Third, we define a tick imbalance bar (TIB) as a <img src="documentation_eq09135103650554810279.png" alt="$T^*$" style="width:16px;height:11px;"> - contiguous subset of ticks such that the following condition is met:</p><p>$$T^* =\underset{T}{\textrm{argmin}} \left\lbrace \left|\theta_T \right|\ge
E_0 \left\lbrack T\right\rbrack \;\left|2P\left\lbrack b_t =1\right\rbrack -1\right|\right\rbrace$$</p><pre class="error">Error updating Text.

 String scalar or character vector must have valid interpreter syntax: 
$$T^* =\underset{T}{\textrm{argmin}} \left\lbrace \left|\theta_T \right|\ge E_0 \left\lbrack T\right\rbrack \;\left|2P\left\lbrack b_t =1\right\rbrack -1\right|\right\rbrace$$
</pre><p>where the size of the expected imbalance is implied by <img src="documentation_eq15495665423813303751.png" alt="$\left|2P\left\lbrack b_t =1\right\rbrack -1\right|$" style="width:98px;height:15px;">. When <img src="documentation_eq03085669592695804257.png" alt="$\theta_T$" style="width:14px;height:13px;"> is more imbalanced than expected, a low <img src="documentation_eq14047577632175690031.png" alt="$T$" style="width:11px;height:10px;"> will satisfy these conditions. Accordingly, TIB's are produced more frequently under the presence of informed trading (<i>asymmetric information that triggers one-side trading</i>). In fact, we can understand TIBs as buckets of trades containing equal amounts of information (regardless of the volumes, prices, or ticks traded).</p><p><b>Usage in Matlab:</b></p><p>The name-value arguments for the method are:</p><div><ul><li><b>ticks</b>(matrix): tick market prices for a security with the corresponding volumes. There is no default value for this parameter.</li><li><b>window</b>(double): number of prior observations to use for the sampling. Default value is 15.</li></ul></div><p>Usage:</p><pre class="codeinput"><span class="comment">% all create a matrix of prices and volumes</span>
tick_prices = [heston_prices(:, 1) volumes];

<span class="comment">% the output is an OHLCV dataset</span>
tib = sim.tib(<span class="string">"ticks"</span>, tick_prices, <span class="string">"window"</span>, 20);
<span class="comment">% ploting the resutls</span>
priceandvol(tib);
</pre><img vspace="5" hspace="5" src="documentation_08.png" alt=""> <h2 id="18">Volume and Dollar Imbalance Bars</h2><p>The idea behind volume imbalance bars (VIB's) and dollar imbalance bars (DIB's) is to extend the concept of tick imbalance bars (TIB's). We would like to sample bars when volume or dollar imbalances diverge from our expectations. Based on the same notions of tick rule and boundary condition <img src="documentation_eq16964906757373332202.png" alt="$b_0$" style="width:11px;height:13px;"> as we discussed for TIB's, we will define a procedure to determine the index of the next sample, <img src="documentation_eq14047577632175690031.png" alt="$T$" style="width:11px;height:10px;">. First, we define the imbalance at time <img src="documentation_eq14047577632175690031.png" alt="$T$" style="width:11px;height:10px;"> as:</p><p><img src="documentation_eq12290763710785753106.png" alt="$$b_t =\sum_{t=1}^T b_t v_t$$" style="width:75px;height:43px;"></p><p>where <img src="documentation_eq08818069549110672446.png" alt="$v_t$" style="width:10px;height:10px;"> may represent either the number of securities traded (VIB) or the dollar amount exchanged (DIB). Your choice of <img src="documentation_eq08818069549110672446.png" alt="$v_t$" style="width:10px;height:10px;"> is what determines whether you are sampling according to the former or the latter. Second, we compute the expected value of <img src="documentation_eq03085669592695804257.png" alt="$\theta_T$" style="width:14px;height:13px;"> at the beginning of the bar</p><p><img src="documentation_eq14511070867479396388.png" alt="$$E_0 \left\lbrack \theta_T \right\rbrack =E_0 \left\lbrack \sum_{t\left|b_t&#xA;=1\right.}^T v_t \right\rbrack -E_0 \left\lbrack \sum_{t\left|b_t =-1\right.}^T&#xA;v_t \right\rbrack =E_0 \left\lbrack T\right\rbrack \left(P\left\lbrack b_t =1\right\rbrack&#xA;E_0 \left\lbrack v_t \left|b_t =1\right.\right\rbrack -P\left\lbrack b_t =-1\right\rbrack&#xA;E_0 \left\lbrack v_t \left|b_t =-1\right.\right\rbrack \right)$$" style="width:656px;height:54px;"></p><p>Let us denote <img src="documentation_eq15050380559329805389.png" alt="$v^+ =P\left\lbrack b_t \;=1\right\rbrack E_0 \left\lbrack v_t \left|b_t =1\right.\right\rbrack ,v^- =P\left\lbrack b_t =-1\right\rbrack E_0 \left\lbrack v_t \left|b_t =-1\right.\right\rbrack$" style="width:400px;height:16px;">, so that <img src="documentation_eq07941310347203328177.png" alt="${E_0 \left\lbrack T\right\rbrack }^{-1} \;E_0 \left\lbrack \sum_t v_t \right\rbrack =E_0 \left\lbrack v_t \right\rbrack =v^+ +v^-$" style="width:244px;height:19px;">. You can think of <img src="documentation_eq12475935980063826933.png" alt="$v^+$" style="width:15px;height:13px;"> and <img src="documentation_eq18079543746226147844.png" alt="$v^-$" style="width:14px;height:9px;"> as decomposing the initial expectation of <img src="documentation_eq08818069549110672446.png" alt="$v_t$" style="width:10px;height:10px;"> into the component contribuited by buys and the component constribuited by sells. Then</p><p><img src="documentation_eq17365857777504605021.png" alt="$$E_0 \left\lbrack \theta_T \right\rbrack =E_0 \left\lbrack T\right\rbrack&#xA;\left(v^+ -v^- \right)=E_0 \left\lbrack T\right\rbrack \left(2v^+ -E_0 \left\lbrack&#xA;v_t \right\rbrack \right)$$" style="width:318px;height:18px;"></p><p>In practice, we can estimate $E_0 \left\lbrack T\right\rbrack \;$as an exponentially weighted moving average of <img src="documentation_eq14047577632175690031.png" alt="$T$" style="width:11px;height:10px;"> values from prior bars, and <img src="documentation_eq05783160204861844766.png" alt="$\left(2v^+ -E_0 \left\lbrack v_t \right\rbrack \right)$" style="width:90px;height:16px;"> as an exponentially weighted moving average of <img src="documentation_eq10235726908016813512.png" alt="$v_t b_t$" style="width:22px;height:13px;"> values from prior bars. Third, we define VIB or DIB as a <img src="documentation_eq09135103650554810279.png" alt="$T^*$" style="width:16px;height:11px;"> - contiguous subset of ticks such that the following condition is met:</p><p>$$T^* =\underset{T}{\textrm{argmin}} \left\lbrace \left|\theta_T \right|\ge
E_0 \left\lbrack T\right\rbrack \left|2v^+ -E_0 \left\lbrack v_t \right\rbrack
\right|\right\rbrace$$</p><pre class="error">Error updating Text.

 String scalar or character vector must have valid interpreter syntax: 
$$T^* =\underset{T}{\textrm{argmin}} \left\lbrace \left|\theta_T \right|\ge E_0 \left\lbrack T\right\rbrack \left|2v^+ -E_0 \left\lbrack v_t \right\rbrack \right|\right\rbrace$$
</pre><p>where the size of the expected imbalance is implied by <img src="documentation_eq17606795727393465814.png" alt="$\left|2v^+ -E_0 \left\lbrack v_t \right\rbrack \right|$" style="width:86px;height:16px;">. When <img src="documentation_eq03085669592695804257.png" alt="$\theta_T$" style="width:14px;height:13px;"> is more imbalanced than expected, a low <img src="documentation_eq14047577632175690031.png" alt="$T$" style="width:11px;height:10px;"> will satisfy these conditions. This is the information-based analogue of volume and dollar bars, and like its predecessor, it addresses the same concerns regarding tick fragmentation and outliers. Furthermore, <b>it also addresses the issue of corporate actions</b>, <i>because the above procedure does not rely on a constant bar size. Instead, the bar size is adjusted dynamically.</i></p><p><b>Usage in Matlab:</b></p><p>The name-value arguments for the method are:</p><div><ul><li><b>ticks</b>(matrix): tick market prices for a security with the corresponding volumes. There is no default value for this parameter.</li><li><b>window</b>(double): number of prior observations to use for the sampling. Default value is 15.</li></ul></div><p>Usage:</p><pre class="codeinput"><span class="comment">% all create a matrix of prices and volumes</span>
tick_prices = [heston_prices(:, 1) volumes];

<span class="comment">% the output is an OHLCV dataset - Dollar Imbalance Bars. If the user wants</span>
<span class="comment">% the Volume information bars, please change the method name to vib.</span>
dib = sim.dib(<span class="string">"ticks"</span>, tick_prices, <span class="string">"window"</span>, 20);
<span class="comment">% ploting the resutls</span>
priceandvol(dib);
</pre><img vspace="5" hspace="5" src="documentation_09.png" alt=""> <h2 id="19">Future Work</h2><p>For the next versions of the toolbox, is intended to add: Systemic risk Indicators, Volatility Estimators (for Low and High frequency data points), Statistical Tests for rejecting the Efficient Market Hypotheses, ETF builders, Asset Allocation methods, and Microstructural features.</p><p>Basically, this toolbox is intended to be the <a href="https://scikit-learn.org/stable/">Scikit-Learn</a> of Matlab for Quantitative finance.</p><p><b>Disclaimer</b></p><div><ul><li>This article is not intended to provide any investment recommendation by any means. It serves solely with an educational purpose.</li><li>The views expressed in this document belong to the author and do not necessarily reflect the organization's view he is affiliated with.</li></ul></div><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Stochastic Valuation Processes
%% Rationale
% This toolbox packages a set of stochastic processes for prices and rates simulation, 
% aiming to create a synthetic dataset for quantitative back-testing of trading 
% strategies and asset allocations methods. 
% 
% Simulating synthetic stock prices and bond rates provides an alternative back-testing 
% method that uses history to generate datasets with statistical characteristics 
% estimated from the observed data. This method allows back-testing on a large 
% sample of unseen scenarios, hence reducing the likelihood of overfitting to 
% a particular historical data set.
% 
% Because each trading strategy needs an implementation tactic (a.k.a., trading 
% rules) to enter, maintain, and exit the respective positions on each instrument, 
% a simulation over thousands of different scenarios is mandatory. However, there 
% is an implicit tradeoff. 
% 
% The historical data will show the 'real' state of the financial instruments 
% based on the realized combinations of events that affect each market. Thereby, 
% a traditional portfolio manager will design a set of rules that optimize or 
% hedge the profits for those specific combinations of events. Therefore, an investment 
% strategy that relies on parameters fitted solely by one combination of events 
% is doomed to fail.
% 
% Such a framework for designing trading strategies is limited in the amount 
% of knowledge that can incorporate. So, simulating thousands or even millions 
% of possibles scenarios for the future will robust the way that an econometric 
% method exploits an inefficiency in the market.
% 
% Based on the previous postulate, I have created a toolbox that packages different 
% stochastic processes (a.k.a, valuation methods) for back-testing synthetic data. 
% 
% The processes that were for this version of the toolbox are: 
% 
% *Stock prices*
%% 
% * Brownian Motion
% * Geometric Brownian motion
% * Merton model
% * Heston model
%% 
% *Bond Rates*
%% 
% * Vasicek model
% * Cox Ingersoll Ross model
%% 
% Without further due, let's briefly dive into each process and how you can 
% use the toolbox in your Matlab session.
%% Introduction to the Matlab class
% All the processes are methods that recreate the price path for an asset based 
% on the user's configuration. As such, the user can initialize the class with 
% the following command.
% 
% Please be aware that the user should enter the parameters as name-value arguments 
% for the definition of the class.

% Creating the object that has the initialized class 
% This is read as follows: Generate 5 securities with 252 datapoints
% each, were the time step between each observation is 1, and  the start
%  price for the securities is $100.
sim = randomProcesses("n", 5, "T", 252, "h", 1, "s0", 100);
%% 
% In this case, each name-value argument is defined as follows:
%% 
% * *T:* number of observations to generate for each time series.
% * *h:* the size of the step. 
% * *n:* number of paths to generate.
% * *s0:* initial price to the state for each of path to generate, be aware 
% that if you want to simulate rates, this number is considered as a pe
% * rcentage (e.g., 30 = 0.3 in the rates environment).
% * *sigma:* trading intensity. This parameter is used for the volume generation 
% process and is not related to the associated volatility of each instrument.
%% 
% In the case the user wants a rapid check of the documentation for each process, 
% he/she can input the following command in the Matlab console. 

doc("randomProcesses")

%% Brownian Motion
% This method implements  a discrete time stochastic process for a Brownian 
% motion that satisfies the following stochastic differential equation (SDE):
% 
% $$dX_t =\mu X_t \textrm{dt}+\sigma \;X_t \;dW_t$$
% 
% $$X\left(0\right)=X_0$$
% 
% The Euler–Maruyama method is used for the numerical solution of the SDE and 
% has the following recurrence:
% 
% $$\begin{array}{l}X\left(k+1\right)=X\left(k\right)+\mu X\left(k-1\right)\Delta 
% t+\sigma X\left(k-1\right)W\;\\\textrm{where}\;\\W=Z\left(k\right)\sqrt{\Delta 
% t\;}\\\;Z\left(k\right)\;\textrm{is}\;\textrm{white}\;\textrm{noise}\end{array}$$
% 
% 
% 
% The name-value arguments for the method are: 
%
% * *mu*(float): Historical means of returns
% * *sigma*(float): Historical volatility of returns
% * *sto_vol*(logical): Optional argument for the helper that states if the 
% volatility should be constant of stochastic in the data generation process. 
% Default is *false* for this process.
%
% Usage:

% Generate the prices paths and save the variable
brownian_prices = sim.brownian_prices("mu", 0.04, "sigma", 0.15);

% plot the results
plot(brownian_prices) 
title('Assets simulated prices for Brownian Motion')
ylabel('Prices')
xlabel('Time step')

%% Geometric Brownian Motion
% The Geometric Brownian Motion (GBM) was popularized by Fisher Black and Myron 
% Scholes in their paper The Pricing of Options and Corporate Liabilities. In 
% that paper, they derive the Black Scholes equation. The GBM is essentially a 
% Brownian Motion with constant drift and a stochastic volatility component. 
% 
% The stochastic differential equation (SDE) which describes the evolution of 
% a Geometric Brownian Motion stochastic process is the following:
% 
% $$\begin{array}{l}dX_t =\mu X_t \textrm{dt}+\sigma \left(t\right)X_t \;dW_t 
% \\X\left(0\right)=X_0 \end{array}$$
% 
% The Euler–Maruyama method is used for the numerical solution of the SDE and 
% has the following recurrence:
% 
% $$\begin{array}{l}X\left(k+1\right)=X\left(k\right)+\textrm{uX}\left(k-1\right)\Delta 
% t+\sigma \left(k\right)X\left(k-1\right)W\\\textrm{where}\;\\W=Z\left(k\right)\sqrt{\Delta 
% t}\;\\Z\left(k\right)\;\textrm{is}\;\textrm{white}\;\textrm{noise}\;\end{array}$$
% 
% The name-value arguments for the method are: 
%
% * *mu*(float): Historical means of returns
% * *sigma*(float): Historical volatility of returns
% * *sto_vol*(logical): Optional argument for the helper that states if the 
% volatility should be constant of stochastic in the data generation process. 
% Default is *true* for this process.

% Usage:

% Generate the prices paths and save the variable
gbm_prices = sim.gbm_prices("mu", 0.04, "sigma", 0.15);

% plot the results
plot(gbm_prices) 
title('Assets simulated prices for Geometric Brownian Motion')
ylabel('Prices')
xlabel('Time step')
%% Merton’s Jump-Diffusion Model
% In essence, this is a process that allows for a positive probability of a 
% stock price change of extraordinary magnitude, no matter how small the time 
% interval between successive observations. More formally, this is a Poisson-driven 
% process, in which the "event" is the arrival of an essential piece of information 
% that creates an abnormal increase/decrease in price. 
% 
% The stochastic differential equation (SDE) which describes the evolution of 
% a Merton stochastic process is the following:
% 
% $$\begin{array}{l}dX_t =\mu X_t \textrm{dt}+\sigma \left(t\right)X_t \;dW_t 
% +dJ_t \\X\left(0\right)=X_0 \end{array}$$
% 
% The Euler–Maruyama method is used for the numerical solution of the SDE and 
% has the following recurrence:
% 
% $$\begin{array}{l}X\left(k+1\right)=X\left(k\right)+\mu X\left(k-1\right)\Delta 
% t+\sigma \left(t\right)X\left(k-1\right)W+X\left(k\right)\left(\sum_{i=0}^{N_t 
% } \left(Y_i -1\right)\right)\\\textrm{where}\\N_t \;\textrm{is}\;a\;\textrm{Poisson}\;\textrm{process}\;\textrm{with}\;\textrm{rate}\;\lambda 
% \;\textrm{and}\;Y_i \;\textrm{has}\;a\;\log \;\textrm{normal}\;\textrm{distribuition}\ldotp 
% \;\\\textrm{Also}\;W=Z\left(k\right)\sqrt{\Delta t}\;\\Z\left(k\right)\;\textrm{is}\;\textrm{white}\;\textrm{noise}\ldotp 
% \end{array}$$
% 
% 
% 
% The name-value arguments for the method are: 
%
% * *lambda*(double): Moment of arrival of an important piece of information.
% * *mu*(double): Historical mean of returns.
% * *sigma*(double): Historical volatility of returns.
% * *sto_vol*(logical): Optional argument for the helper that states if the 
% volatility should be constant of stochastic in the data generation process. 
% Default is *true* for this process.
%
% Usage:

% Generate the prices paths and save the variable
% The arrival of critical information will arrive every 30
% iterations until the end of the data points.
merton_prices = sim.merton_prices("mu", 0.04, "sigma", 0.15, 'lambda', 30);

% plot the results
plot(merton_prices) 
title('Assets simulated prices for the Merton’s Jump-Diffusion model')
ylabel('Prices')
xlabel('Time step')
%% Heston Model
% The original Geometric Brownian Motion stochastic process assumes that volatility 
% over time is constant. In the early 1990s, Steven Heston relaxed this assumption 
% and extended the Geometric Brownian Motion model to include stochastic volatility. 
% The resulting model is called the Heston model. 
% 
% In the Heston model, the volatility over time evolves according to the Cox 
% Ingersoll Ross stochastic process. As such, the model makes use of two Wiener 
% processes, one for the Cox Ingersoll Ross process and another for the Geometric 
% Brownian Motion process. These two Wiener processes are correlated using Singular 
% Value Decomposition.
% 
% The stochastic differential equations (SDE) for the Cox-Ingersoll-Ross and 
% the Heston model are
% 
% $$\begin{array}{l}\textrm{Price}\;\textrm{evolution}\\dS_t =\mu S_t \;\textrm{dt}+S_t 
% \sqrt{V}dW_1 \;\\S\left(0\right)=S_0 \\\;\\\textrm{Volatility}\;\textrm{evolution}\\dV_t 
% =k\left(\theta -V_t \right)\textrm{dt}+\sigma \sqrt{V}dW_2 \\V\left(0\right)=V_0 
% \;\end{array}$$
% 
% The Euler–Maruyama method is used for the numerical solution of the SDE and 
% has the following recurrence:
% 
% $$\begin{array}{l}\textrm{Price}\;\textrm{numerical}\;\textrm{approximation}\\S\left(i\right)=\textrm{rf}\;S\left(i-1\right)\Delta 
% t+\sqrt{V\left(i\right)}S\left(i-1\right)W_1 \\\textrm{where}\;W_1 =Z_1 \left(k\right)\sqrt{\Delta 
% t}\\Z_1 \left(k\right)\;\textrm{is}\;\textrm{the}\;\textrm{correlated}\;\textrm{white}\;\textrm{noise}\\\;\\\textrm{Volatility}\;\textrm{numerical}\;\textrm{approximation}\\V\left(j\right)=k\left(\theta 
% -V\left(j-1\right)\right)\Delta t+\sigma \sqrt{V\left(j-1\right)}W_2 \\\textrm{where}\;W_2 
% =Z_2 \left(k\right)\sqrt{\Delta t}\;\\Z_2 \left(k\right)\;\textrm{is}\;\textrm{the}\;\textrm{correlated}\;\textrm{white}\;\textrm{noise}\end{array}$$
% 
% 
% 
% The name-value arguments for the method are:
%
% * *rf*(double): Risk-free interest rate, theoretical rate on an asset carrying 
% no risk. Default value is 0.02
% * *theta*(double): Long term price variance. Default value is 1
% * *k*(double): Rate reversion to the long term variance. Default value is 
% 0.5
% * *sigma*(double): Historical volatility of returns. Default value is 1
% * *sto_vol*(logical): Optional argument for the helper that states if the 
% volatility should be constant of stochastic in the data generation process. 
% Default is *false* for this process.
%
% Usage:

% Generate the prices paths and save the variable
heston_prices = sim.heston_prices('rf', 0.01, 'theta', 0.5, ...
    'k', 0.8, 'sigma', 0.2);

% plot the results
plot(heston_prices) 
title('Assets simulated prices for the Heston model')
ylabel('Prices')
xlabel('Time step')

%% Vasicek interest rate model
% The Vasicek interest rate model (or merely the Vasicek model) is a mathematical 
% method of modeling interest rate movements. The model describes the evolution 
% of an interest rate as a factor composed of market risk, time, and equilibrium 
% value, where the rate tends to revert towards the mean of those factors over 
% time. Essentially, it predicts where interest rates will end up at the end of 
% a given period, given current market volatility, the long-run mean interest 
% rate value, and a given market risk factor.
% 
% The stochastic differential equation (SDE) for the Vasicek Interest Rate Model 
% process is given by
% 
% $$\begin{array}{l}dS_t =\lambda \left(\mu -S_t \right)+\sigma dW_t \\S\left(0\right)=S_0 
% \end{array}$$
% 
% The Euler–Maruyama method is used for the numerical solution of the SDE and 
% has the following recurrence:
% 
% $$\begin{array}{l}S\left(k\right)=\lambda \left(\mu -S\left(k-1\right)\right)\Delta 
% t+\sigma S\left(k-1\right)W\\\textrm{where}\;\\W=Z\left(k\right)\sqrt{\Delta 
% t}\\Z\left(k\right)\;\textrm{is}\;\textrm{white}\;\textrm{noise}\end{array}$$
% 
% 
% 
% The name-value arguments for the method are:
% 
% * *mu*(double): Long term mean level. All future trajectories of s will evolve 
% around a mean level μ in the long run. Default value is 0
% * *sigma*(double): Instantaneous volatility, measures instant by instant the 
% amplitude of randomness entering the system. Higher σ implies more randomness. 
% Default value is 1
% * *lambda*(double): Speed of reversion. λ characterizes the velocity at which 
% such trajectories will regroup around μ in time. Default value is 0.5
% * *sto_vol*(logical): Optional argument for the helper that states if the 
% volatility should be constant of stochastic in the data generation process. 
% Default is *false* for this process.
%
% Usage:

% Create the object for the rate series
% The following object can be read as follows: Create 5 instruments with
% 252 observations each, were the time step between the observations is 1
% and the initial rate is 0.02 (i.e., 2%)
sim2 = randomProcesses('n', 5, 'T', 252, 'h', 1, 's0', 2);

% Generate the prices paths and save the variable
vas_rates = sim2.vas_rates("mu", 0.018, "sigma", 0.03, 'lambda', 0.9);

% plot the results
plot(vas_rates) 
title('Rates simulated for the Vasicek interest rate model')
ylabel('Rates')
xlabel('Time step')
%% Cox-Ingersoll-Ross interest rate model
% The Cox-Ingersoll-Ross model (CIR) is a mathematical formula used to model 
% interest rate movements and is driven by a sole source of market risk. It is 
% used as a method to forecast interest rates.  The stochastic process is often 
% used in the valuation of interest rate derivatives and has been used in the 
% Heston model to describe the evolution of volatility over time. One interesting 
% characteristic of the CIR stochastic process is that it is mean reverting.
% 
% _*The main distinction with the Vasicek model is that the Cox-Ingersoll Ross 
% model does not allow for negative interest rates.*_
% 
% The stochastic differential equation (SDE) for the Cox-Ingersoll-Ross Interest 
% Rate Model process is given by
% 
% $$\begin{array}{l}dS_t =\lambda \left(\mu -S_t \right)\textrm{dt}+o\sqrt{S_t 
% }dW_t \\S\left(0\right)=S_0 \end{array}$$
% 
% The Euler–Maruyama method is used for the numerical solution of the SDE and 
% has the following recurrence:
% 
% $$\begin{array}{l}S\left(k\right)=\lambda \left(\mu -S\left(k-1\right)\right)\Delta 
% t+\sigma \sqrt{S\left(k-1\right)}W\\\textrm{where}\\W=Z\left(k\right)\sqrt{\Delta 
% t}\;\\Z\left(k\right)\;\textrm{is}\;\textrm{white}\;\textrm{noise}\end{array}$$
% 
% 
% 
% The name-value arguments for the method are:
% 
% * *mu*(double): Long term mean level. All future trajectories of s will evolve 
% around a mean level μ in the long run. Default value is 0
% * *sigma*(double): Instantaneous volatility, measures instant by instant the 
% amplitude of randomness entering the system. Higher σ implies more randomness. 
% Default value is 1
% * *lambda*(double): Speed of reversion. λ characterizes the velocity at which 
% such trajectories will regroup around μ in time. Default value is 0.5
% * *sto_vol*(logical): Optional argument for the helper that states if the 
% volatility should be constant of stochastic in the data generation process. 
% Default is *false* for this process.
%
% Usage:

% Generate the prices paths and save the variable
cir_rates = sim2.cir_rates("mu", 0.018, "sigma", 0.03, 'lambda', 0.9);

% plot the results
plot(cir_rates) 
title('Rates simulated for the Cox-Ingersoll-Ross interest rate model')
ylabel('Rates')
xlabel('Time step')
%% Utilities
% Along with the stochastic models for stock prices and interest rates, several 
% utility methods were implemented. Such as *Information driven bars* (see _Advances 
% in Financial Machine Learning by Marcos López de Prado_), *volume generation, 
% or order flow* for each stock (see _Asymmetric Information and the Distribution 
% of Trading Volume, Matthijs Lof_).
% 
% 
% Order Flow
% Volume generation process based on the number of informed traders and the 
% number of liquidity seekers for the market of a security. To check the details 
% of the generation process please see:
%
% * Lof, Matthijs and van Bommel, Jos, Asymmetric Information and the Distribution 
% of Trading Volume (May 29, 2019). Available at SSRN: <https://ssrn.com/abstract=2726187 
% https://ssrn.com/abstract=2726187> or <https://dx.doi.org/10.2139/ssrn.2726187 
% http://dx.doi.org/10.2139/ssrn.2726187>
%
% *Usage in Matlab:*
% 
% The name-value arguments for the method are:
%
% * *eta*(double): Proportion of informed trade. Default value is 0.1
% * *M*(double): Proportion of liquidity seekers. Default value is 0.3
% * *market_prices*(matrix): tick prices for an financial instrument.
%
% Usage:

volumes = sim.order_flow("eta", 0.15, "market_prices", heston_prices(:, 1));
bar(volumes,'EdgeColor','none');
ylabel({'Volume'});
xlabel({'Time Step'});
title({'Generated Volumes for a Heston model'});
% Information Driven Bars
% The following descriptions came from the book <https://www.bookdepository.com/Advances-Financial-Machine-Learning-Marcos-Lopez-de-Prado/9781119482086?ref=grid-view&qid=1590373792725&sr=1-1 
% Advances in Financial Machine Learning> by Marcos López de Prado
%% Tick Imbalance Bars
% Consider a sequence of ticks ${\left\lbrace \left(p_t \;,v_t \;\right)\right\rbrace 
% }_{t=1,\ldotp \ldotp \ldotp ,T}$ , where $p_t$ is the price associated with 
% tick $t$ and $v_t$ is the volume associated with tick $t$. The so-called tick 
% rule defines a sequence ${\left\lbrace b_t \right\rbrace }_{t=1,\ldotp \ldotp 
% \ldotp ,T}$ where
% 
% $$b_t =\left\lbrace \begin{array}{ll}b_{t-1}  & \textrm{if}\;\Delta p_t =0\\\frac{\left|\Delta 
% p_t \right|}{\Delta p_t } & \textrm{if}\;\Delta p_t \not= 0\end{array}\right.$$
% 
% with $b_t \in \left\lbrace -1,1\right\rbrace$, and the boundary condition 
% $b_0$ is set to match the terminal value $b_T$ from the immediately preceding 
% bar. The idea behind tick imbalance bars (TIB's) is to sample bars whenever 
% tick imbalances exceed our expectations. We wish to determine the tick index, 
% $T$, such that the accumulation of signed ticks (signed according to the tick 
% rule) exceeds a given threshold. Next, let us discuss the procedure to determine 
% $T$. 
% 
% First, we define the tick imbalance at time $T$ as
% 
% $$\theta_t =\sum_{t=1}^T b_t$$
% 
% Second, we compute the expected value of $\theta_T$ at the beginning of the 
% bar, $E_0 \left\lbrack \theta_T \right\rbrack =E_0 \left\lbrack T\right\rbrack 
% \left(P\left\lbrack b_t =1\right\rbrack -P\left\lbrack b_t =-1\right\rbrack 
% \right)$, where $E_0 \left\lbrack T\right\rbrack$ is the *expected size of the 
% tick bar*, $P\left\lbrack b_t =1\right\rbrack$ is the unconditional probability 
% that a tick is *classified as a buy*, and $P\left\lbrack b_t =-1\right\rbrack$ is 
% the unconditional probability that a tick is *classified as a sell*. Since $P\left\lbrack 
% b_t =1\right\rbrack +P\left\lbrack b_t =-1\right\rbrack =1$, then $E_0 \left\lbrack 
% \theta_T \right\rbrack =E_0 \left\lbrack T\right\rbrack \left(2P\left\lbrack 
% b_t =1\right\rbrack -1\right)$
% 
% In practice, we can estimate $E_0 \left\lbrack T\right\rbrack$ as an exponentially 
% weighted moving average of $T$ values from prior bars, and $\left(2P\left\lbrack 
% b_t =1\right\rbrack -1\right)$ as an exponentially weighted moving average of 
% $b_t$ values from prior bars.
% 
% Third, we define a tick imbalance bar (TIB) as a $T^*$ - contiguous subset 
% of ticks such that the following condition is met:
% 
% $$T^* =\underset{T}{\textrm{argmin}} \left\lbrace \left|\theta_T \right|\ge 
% E_0 \left\lbrack T\right\rbrack \;\left|2P\left\lbrack b_t =1\right\rbrack -1\right|\right\rbrace$$
% 
% where the size of the expected imbalance is implied by $\left|2P\left\lbrack 
% b_t =1\right\rbrack -1\right|$. When $\theta_T$ is more imbalanced than expected, 
% a low $T$ will satisfy these conditions. Accordingly, TIB's are produced more 
% frequently under the presence of informed trading (_asymmetric information 
% that triggers one-side trading_). In fact, we can understand TIBs as buckets 
% of trades containing equal amounts of information (regardless of the volumes, 
% prices, or ticks traded).
% 
% *Usage in Matlab:*
% 
% The name-value arguments for the method are:
% 
% * *ticks*(matrix): tick market prices for a security with the corresponding 
% volumes. There is no default value for this parameter.
% * *window*(double): number of prior observations to use for the sampling. 
% Default value is 15.
%
% Usage:

% all create a matrix of prices and volumes
tick_prices = [heston_prices(:, 1) volumes];

% the output is an OHLCV dataset
tib = sim.tib("ticks", tick_prices, "window", 20);
% ploting the resutls
priceandvol(tib);
%% Volume and Dollar Imbalance Bars
% The idea behind volume imbalance bars (VIB's) and dollar imbalance bars (DIB's) 
% is to extend the concept of tick imbalance bars (TIB's). We would like to sample 
% bars when volume or dollar imbalances diverge from our expectations. Based on 
% the same notions of tick rule and boundary condition $b_0$ as we discussed for 
% TIB's, we will define a procedure to determine the index of the next sample, 
% $T$. First, we define the imbalance at time $T$ as:
% 
% $$b_t =\sum_{t=1}^T b_t v_t$$
% 
% where $v_t$ may represent either the number of securities traded (VIB) or 
% the dollar amount exchanged (DIB). Your choice of $v_t$ is what determines whether 
% you are sampling according to the former or the latter. Second, we compute the 
% expected value of $\theta_T$ at the beginning of the bar
% 
% 
% 
% $$E_0 \left\lbrack \theta_T \right\rbrack =E_0 \left\lbrack \sum_{t\left|b_t 
% =1\right.}^T v_t \right\rbrack -E_0 \left\lbrack \sum_{t\left|b_t =-1\right.}^T 
% v_t \right\rbrack =E_0 \left\lbrack T\right\rbrack \left(P\left\lbrack b_t =1\right\rbrack 
% E_0 \left\lbrack v_t \left|b_t =1\right.\right\rbrack -P\left\lbrack b_t =-1\right\rbrack 
% E_0 \left\lbrack v_t \left|b_t =-1\right.\right\rbrack \right)$$
% 
% 
% 
% Let us denote $v^+ =P\left\lbrack b_t \;=1\right\rbrack E_0 \left\lbrack v_t 
% \left|b_t =1\right.\right\rbrack ,v^- =P\left\lbrack b_t =-1\right\rbrack E_0 
% \left\lbrack v_t \left|b_t =-1\right.\right\rbrack$, so that ${E_0 \left\lbrack 
% T\right\rbrack }^{-1} \;E_0 \left\lbrack \sum_t v_t \right\rbrack =E_0 \left\lbrack 
% v_t \right\rbrack =v^+ +v^-$. You can think of $v^+$ and $v^-$ as decomposing 
% the initial expectation of $v_t$ into the component contribuited by buys and 
% the component constribuited by sells. Then 
% 
% $$E_0 \left\lbrack \theta_T \right\rbrack =E_0 \left\lbrack T\right\rbrack 
% \left(v^+ -v^- \right)=E_0 \left\lbrack T\right\rbrack \left(2v^+ -E_0 \left\lbrack 
% v_t \right\rbrack \right)$$
% 
% In practice, we can estimate $E_0 \left\lbrack T\right\rbrack \;$as an exponentially 
% weighted moving average of $T$ values from prior bars, and $\left(2v^+ -E_0 \left\lbrack 
% v_t \right\rbrack \right)$ as an exponentially weighted moving average of $v_t 
% b_t$ values from prior bars. Third, we define VIB or DIB as a $T^*$ - contiguous 
% subset of ticks such that the following condition is met:
% 
% $$T^* =\underset{T}{\textrm{argmin}} \left\lbrace \left|\theta_T \right|\ge 
% E_0 \left\lbrack T\right\rbrack \left|2v^+ -E_0 \left\lbrack v_t \right\rbrack 
% \right|\right\rbrace$$
% 
% where the size of the expected imbalance is implied by $\left|2v^+ -E_0 \left\lbrack 
% v_t \right\rbrack \right|$. When $\theta_T$ is more imbalanced than expected, 
% a low $T$ will satisfy these conditions. This is the information-based analogue 
% of volume and dollar bars, and like its predecessor, it addresses the same concerns 
% regarding tick fragmentation and outliers. Furthermore, *it also addresses the 
% issue of corporate actions*, _because the above procedure does not rely on a 
% constant bar size. Instead, the bar size is adjusted dynamically._
% 
% *Usage in Matlab:*
% 
% The name-value arguments for the method are:
%
% * *ticks*(matrix): tick market prices for a security with the corresponding 
% volumes. There is no default value for this parameter.
% * *window*(double): number of prior observations to use for the sampling. 
% Default value is 15.
%
% Usage:

% all create a matrix of prices and volumes
tick_prices = [heston_prices(:, 1) volumes];

% the output is an OHLCV dataset - Dollar Imbalance Bars. If the user wants
% the Volume information bars, please change the method name to vib.
dib = sim.dib("ticks", tick_prices, "window", 20);
% ploting the resutls
priceandvol(dib);
%% Future Work
% For the next versions of the toolbox, is intended to add: Systemic risk Indicators, 
% Volatility Estimators (for Low and High frequency data points), Statistical 
% Tests for rejecting the Efficient Market Hypotheses, ETF builders, Asset Allocation 
% methods, and Microstructural features. 
% 
% Basically, this toolbox is intended to be the <https://scikit-learn.org/stable/ 
% Scikit-Learn> of Matlab for Quantitative finance. 
%% 
% *Disclaimer*
% 
% * This article is not intended to provide any investment recommendation by 
% any means. It serves solely with an educational purpose.
% * The views expressed in this document belong to the author and do not necessarily 
% reflect the organization's view he is affiliated with.
##### SOURCE END #####
--></body></html>